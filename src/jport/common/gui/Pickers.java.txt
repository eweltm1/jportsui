package ?

import java.awt.Color;
import java.awt.Component;
import java.awt.Container;
import java.awt.event.ActionEvent;
import javax.swing.AbstractButton;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.JCheckBox;
import javax.swing.JComboBox;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButton;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;


/**
 * Creates a Component Container whose UI presentation of options / items for the user to pick
 * from accommodates a variety of javax.swing.JComponent implementations.
 *
 * For example :
 * - JButton_PopupMenu
 * - JList
 * - JToggleButton
 * - JToolBar
 * - JRadioButton
 * - JComboBox
 * - JCheckBox for binary state, ex. enable/disable, on/off, yes/no
 *
 * @author sgbaber
 */
public class Pickers
    implements
          Factory
        , GuiApi
{
    static private enum EPresentation
        { POPUP
            {   @Override Component starter( final Menuable[] options )
                {   final JPopupMenuProvidable provider = new JPopupMenuProvidable() // anonymous class
                            {   @Override public JPopupMenu provideJPopupMenu()
                                {   return MenuPopupFactory.createJPopupMenu( options );
                                }
                            };
                    return new JButton_PopupMenu( null, null, provider );
                }
            }
        // ---------------------------------------------
        , MENU
            {   @Override Component starter( final Menuable[] options )
                {   return MenuPopupFactory.createJMenu( null, MenuPopupFactory.createJPopupMenu( options ) );
                }
            }
        // ---------------------------------------------
        , TABLE
            {   @Override Component starter( final Menuable[] options )
                {   final TableModel_Picker tm = new TableModel_Picker( options );
                    return tm.getJTable();
                }
            }
        // ---------------------------------------------
        , LIST
            {   @Override Component starter( final Menuable[] options )
                {   final JList jl = new JList( options );
                    jl.setSelectedValue( _getSelection( options ), true );
                    final ListSelectionListener lsl = new ListSelectionListener() // anonymous class
                            {   @Override public void valueChanged( final ListSelectionEvent e )
                                {   final int index = e.getFirstIndex();
                                    if( e.getValueIsAdjusting() == false && index >= 0 )
                                    {   final Object selection = jl.getModel().getElementAt( index );
                                        final ActionEvent ae = new ActionEvent( jl, index, "" );
                                        ((Menuable)selection).actionPerformed( ae );
                                    }
                                }
                            };
                    jl.addListSelectionListener( lsl );
                    return jl;
                }
            }
        // ---------------------------------------------
        , SLIDER
        // ---------------------------------------------
        , SPINNER
        // ---------------------------------------------
        , TOGGLE
            {   @Override void populate( final Component component, final Menuable option )
                {   _conformAddAB( JToggleButton.class, option, (Container)component );
                }
                @Override void conclude( final Component component )
                {   _createButtonGroup( (Container)component );
                }
            }
        // ---------------------------------------------
        , TOOL_BAR
            {   @Override Component starter( final Menuable[] options ) { return new JToolBar(); }
                @Override void populate( final Component component, final Menuable option )
                {   _conformAddAB( JToggleButton.class, option, (Container)component );
                }
                @Override void conclude( final Component component )
                {   _createButtonGroup( (Container)component );
                }
            }
        // ---------------------------------------------
        , RADIO
            {   @Override void populate( final Component component, final Menuable option )
                {   _conformAddAB( JRadioButton.class, option, (Container)component );
                }
                @Override void conclude( final Component component )
                {   _createButtonGroup( (Container)component );
                }
            }
        // ---------------------------------------------
        , COMBO
            {   @Override Component starter( final Menuable[] options )
                {   final JComboBox jcb = new JComboBox( options );
                    jcb.setSelectedItem( _getSelection( options ) );
                    return jcb;
                }
            }
        // ---------------------------------------------
        , CHECK
            {   @Override void populate( final Component component, final Menuable option )
                {   _conformAddAB( JCheckBox.class, option, (Container)component );
                }
            }
        // ---------------------------------------------
        , INDICATOR

        ;
                Component starter( final Menuable[] options ) { return new JPanel(); }
                void populate( final Component component, final Menuable option ) {}
                void conclude( final Component component ) {}
        }

    private Pickers() {}

//... binary presentation -> static Container create( final EPresentation presentation, final Menuable m0, final Menuable m1 )

    static private Component create( final EPresentation presentationEnum, final Menuable... options )
    {
        // in cases where Component requires exposure to all options they are passed in
        final Component component = presentationEnum.starter( options );

        for( final Menuable option : options )
        {
            presentationEnum.populate( component, option );
        }

        presentationEnum.conclude( component );
        return component;
    }

    static private ButtonGroup _createButtonGroup( final Container abContainer )
    {
        final AbstractButton[] abs = ClassUtil.keepInstances( AbstractButton.class, abContainer.getComponents() );
        return GuiUtil.createButtonGroup( abs );
    }

    static private Menuable _getSelection( final Menuable[] options )
    {
        for( final Menuable option : options )
        {   // linear search
            if( option.getMutualExclusion() == EMutualExclusion.INCLUDE ) { return option; }
        }
        return null;
    }

    static private AbstractButton _conformAddAB
            ( final Class<? extends AbstractButton> abClassType
            , final Menuable option
            , final Container addToContainer
            )
    {
        try
        {   // miniature version of AbstractButtonFactory
            final AbstractButton ab = abClassType.newInstance();
            ab.setText( option.provideHsiDisplayText() );
            ab.setIcon( option.provideIcon() );
            ab.setToolTipText( option.provideTipText() );
            ab.setEnabled( option.provideIsEnabled() );
            ab.setVisible( option.provideIsVisible() );
            ab.setSelected( option.getMutualExclusion() == EMutualExclusion.INCLUDE );

            ab.addActionListener( option );
            addToContainer.add( ab );
            return ab;
        }
        catch( IllegalAccessException ex )
        {   // should never happen
            MiscUtil.printErrAndStackTrace( ex );
            assert false;
        }
        catch( InstantiationException ex )
        {   // should never happen
            MiscUtil.printErrAndStackTrace( ex );
            assert false;
        }
        return null;
    }

    // ================================================================================
    /**
     * Selector based type that is MVC.
     */
    static abstract private class APicker_<C extends Component>
    {
        final public C kComponent;
        final public Selector.Mutator<Menuable> kSelector;

        private APicker_( final Menuable initial, final Menuable... options )
        {
            kComponent = intro( options );

            for( final Menuable option : options )
            {
                populate( option );
            }

            conclude();

            kSelector = new Selector.Mutator<Menuable>( initial );
        }

        /**
         * @param options for the case where Component creation would require exposure to all options
         * @return
         */
        abstract C intro( final Menuable[] options );
        void populate( final Menuable option ) {}
        void conclude() {}
    }

    static abstract private class APicker_Panel_ extends APicker_<JPanel>
    {
        APicker_Panel_( final Menuable initial, final Menuable... options )
        {
            super( initial, options );
        }

        @Override JPanel intro( final Menuable[] options )
        {
            return new JPanel();
        }
    }

    static private class _Picker_Button extends APicker_Panel_
    {
        _Picker_Button( final Menuable initial, final Menuable... options )
        {
            super( initial, options );
        }

        @Override void conclude()
        {
            _createButtonGroup( (Container)kComponent );
        }
    }

    static private class Picker_Radio extends _Picker_Button
    {
        Picker_Radio( final Menuable initial, final Menuable... options )
        {
            super( initial, options );
        }

        @Override void populate( final Menuable option )
        {
            _conformAddAB( JRadioButton.class, option, kComponent );
        }
    }

    static private class Picker_Check extends _Picker_Button
    {
        Picker_Check( final Menuable option )
        {
            super( option, option ); // single check box
        }

        @Override void populate( final Menuable option )
        {
            _conformAddAB( JCheckBox.class, option, kComponent );
        }
    }

    static private class Picker_Toggle extends _Picker_Button
    {
        Picker_Toggle( final Menuable initial, final Menuable... options )
        {
            super( initial, options );
        }

        @Override void populate( final Menuable option )
        {
            _conformAddAB( JToggleButton.class, option, kComponent );
        }
    }

    static private class Picker_ToolBar extends APicker_<JToolBar>
    {
        Picker_ToolBar( final Menuable initial, final Menuable... options )
        {
            super( initial, options );
        }

        @Override JToolBar intro( final Menuable[] options ) { return new JToolBar(); }

        @Override void populate( final Menuable option )
        {   
            _conformAddAB( JToggleButton.class, option, (Container)kComponent );
        }

        @Override void conclude()
        {   
            _createButtonGroup( (Container)kComponent );
        }
    }


    // ================================================================================
    /**
     * @see Menuable
     */
    static interface Optionable extends
          Providers.HsiDisplayTextProvidable
        , Providers.TipProvidable
        , Providers.IconProvidable
        , Providers.EnabledProvidable
        , Providers.VisibilityProvidable
        , Providers.BackColorProvidable
        , Providers.ForeColorProvidable
        , GuiApi
    {
        static class Adapter implements Optionable, Adaptable
        {
            @Override public String  provideHsiDisplayText() { return Adapter.this.toString(); }
            @Override public String  provideTipText()        { return null; }
            @Override public Icon    provideIcon()           { return null; }
            @Override public boolean provideIsEnabled()      { return true; }
            @Override public boolean provideIsVisible()      { return true; }
            @Override public Color   provideBackColor()      { return null; }
            @Override public Color   provideForeColor()      { return null; }
        }
    }

//... Varg    static public class Option implements Optionable
    {

    }

    // ================================================================================
    /**
     * Creates a table where a Checkbox indicates the user pick.
     */
    @SuppressWarnings("serial")
    static private class TableModel_Picker extends ATableModel_Array_<Menuable>
    {
        /** No Table Header to display. */
        static private enum EColumn implements EnabledProvidable, WidthProvidable, ClassProvidable
                { SELECT( 19, Boolean.class ) { @Override public boolean provideIsEnabled() { return true; } }
                , ICON  ( 28, Icon.class )
                , OPTION( -1, Object.class )
                ;
                        private EColumn( final int pixelWidth, final Class<?> ofClassType )
                            { kPixelWidth = pixelWidth; kOfClassType = ofClassType; }
                        final private int      kPixelWidth;
                        final private Class<?> kOfClassType;
                        @Override public int      provideWidth() { return kPixelWidth; }
                        @Override public Class<?> provideClass() { return kOfClassType; }
                        @Override public boolean  provideIsEnabled() { return false; } // non-editable cell
                }

        private TableModel_Picker( final Menuable[] options )
        {
            super
                ( Menuable.class
                , GuiFactory.DO_NOT_SET_DIMENSION
                , EEditable.ENABLE
                , ERowSelection.NO_SELECTION
                , EScrolling.VERTICALLY_ONLY
                , EShowHeader.DISABLE
                , EAutoSorter.ENABLE
                , EShowGrid.DISABLE
                , EColorize.DISABLE
                , GuiFactory.DO_NOT_SET_FONT
                , EColumn.values()
                );
            toggelSortColumn( EColumn.OPTION );
            this.setRows( options );
        }

        @Override public Object getValueAt( int modelRowIndex, int columnIndex )
        {
            final Menuable option = provideRow( modelRowIndex );
            final EColumn columnEnum = getColumnEnum( EColumn.class, columnIndex );
            switch( columnEnum )
            {
                case SELECT : return ( option.getMutualExclusion() == EMutualExclusion.INCLUDE ) ? Boolean.TRUE : Boolean.FALSE;
                case ICON   : return   option.provideIcon();
                case OPTION : return   option.provideHsiDisplayText();
                default     : return "ERR"; // not expected
            }
        }

        @Override public void setValueAt( final Object value, final int modelRowIndex, final int columnIndex )
        {
            final Menuable option = provideRow( modelRowIndex );
            final EColumn columnEnum = getColumnEnum( EColumn.class, columnIndex );
            switch( columnEnum )
            {
                case SELECT:
                        final ActionEvent ae = new ActionEvent( this, modelRowIndex, value.toString() );
                        option.actionPerformed( ae );
                        break;

                default: break; // not editable
            }
        }
    }
}
